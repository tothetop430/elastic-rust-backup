//! Elasticsearch Hyper Client Samples
//!
//! This sample assumes you have a node running on `localhost`.
//!
//! This sample executes a simple search request against some indexed data.
//! The data is provided by a struct with mapping generated by `elastic_types`.

#![feature(plugin)]
#![plugin(json_str)]

extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate serde_derive;

extern crate elastic_types;
#[macro_use]
extern crate elastic_types_derive;
extern crate elastic_reqwest;

use std::net::Ipv4Addr;
use elastic_reqwest::{SyncElasticClient, SyncFromResponse, RequestParams};
use elastic_reqwest::req::{IndicesCreateRequest, IndexRequest, SearchRequest};
use elastic_reqwest::res::{parse, CommandResponse, IndexResponse, SearchResponse};
use elastic_types::prelude::*;

mod data;
use data::*;

const INDEX: &'static str = "testidx";

fn main() {
    // Create a new client
    let (client, params) = elastic_reqwest::sync::default().unwrap();

    // Wait for refresh when indexing data.
    // Normally this isn't a good idea, but is ok for this example.
    let index_params = RequestParams::default().url_param("refresh", true);

    // Create an index and map our type
    create_index(&client, &params);

    // Index some objects.
    // For lots of data, prefer the `BulkRequest`
    for t in get_data() {
        index_datum(&client, &index_params, &t);
    }

    // Perform a search request and deserialise to `SearchResponse`.
    let res = query(&client, &params);

    println!("results: {}", res.hits().count());

    for hit in res.hits() {
        println!("hit: {:?}", hit);
    }
}

fn create_index<TClient>(client: &TClient, params: &RequestParams) 
    where TClient: SyncElasticClient
{
    let req = IndicesCreateRequest::for_index(INDEX, serde_json::to_string(&Index::default()).unwrap());

    // Create index
    let res = client.elastic_req(&params, req).unwrap();

    parse::<CommandResponse>().from_response(res).unwrap();
}

fn get_data() -> Vec<MyStruct> {
    vec![MyStruct {
             id: 1,
             title: String::from("Some Title"),
             timestamp: Date::now(),
             geo: GeoLocation {
                 ip: Ipv4Addr::new(10, 0, 0, 1),
                 loc: GeoPoint::build(-71.34, 41.12),
             },
         },
         MyStruct {
             id: 2,
             title: String::from("Some Other Title"),
             timestamp: Date::now(),
             geo: GeoLocation {
                 ip: Ipv4Addr::new(10, 0, 0, 2),
                 loc: GeoPoint::build(-71.34, 41.12),
             },
         }]
}

fn index_datum<TClient>(client: &TClient, params: &RequestParams, datum: &MyStruct) 
    where TClient: SyncElasticClient
{
    let req = IndexRequest::for_index_ty_id(INDEX,
                                            MyStruct::name(),
                                            datum.id.to_string(),
                                            serde_json::to_string(&datum).unwrap());

    let res = client.elastic_req(&params, req).unwrap();

    parse::<IndexResponse>().from_response(res).unwrap();
}

fn query<TClient>(client: &TClient, params: &RequestParams) -> SearchResponse<MyStruct> 
    where TClient: SyncElasticClient
{
    let req = SearchRequest::for_index_ty(INDEX,
                                          MyStruct::name(),
                                          json_lit!({
                                                query: {
                                                    query_string: {
                                                        query: "*"
                                                    }
                                                }
                                          }));

    let res = client.elastic_req(&params, req).unwrap();

    parse().from_response(res).unwrap()
}
