#![feature(rustc_private)]

extern crate syntax;
extern crate elastic_codegen;

use std::fs;
use std::fs::File;
use syntax::ast::*;
use syntax::parse::ParseSess;
use syntax::feature_gate::GatedCfgAttr;
use syntax::ext::base::ExtCtxt;
use syntax::ext::expand::ExpansionConfig;
use syntax::print::pprust;
use elastic_codegen::emit::*;
use elastic_codegen::emit::rust::*;
use elastic_codegen::gen::rust::*;

#[test]
fn can_emit_rs_to_file() {
	//Get a file ref
	let _ = fs::remove_file("tests/emit_results/can_emit_to_file.rs");
	let mut f = File::create("tests/emit_results/can_emit_to_file.rs").unwrap();

	//Create an ExtCtxt to use in the emitter
	let sess = ParseSess::new();
	let mut attrs: Vec<GatedCfgAttr> = Vec::new();
	let cx = ExtCtxt::new(
		&sess, 
		Vec::new(), 
		ExpansionConfig::default("".to_string()), 
		&mut attrs
	);

	//Create an emitter
	let emitter = RustEmitter::new(cx);

	//Emit a function signature
	let lifetime = lifetime("'a");
	let mut fun = build_fn("my_fun", vec![
		arg_ptr::<i32>("arg1", Mutability::MutMutable, Some(lifetime)),
		build_arg("arg2", build_ty_ptr("str", Mutability::MutImmutable, Some(lifetime)))
	]);

	let mut result = emitter.emit_str(&"//Autogenerated\n", &mut f);
	result = emitter.emit(&fun, &mut f);

	assert!(result.is_ok());
}