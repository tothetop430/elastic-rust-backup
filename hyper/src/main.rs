#![cfg(feature = "codegen")]
#![feature(rustc_private)]

extern crate syntax;
extern crate aster;
extern crate elastic_codegen;

use std::error::Error;
use std::fs;
use std::fs::{ File, OpenOptions };
use std::io::{ Seek, SeekFrom };
use syntax::ast::*;
use syntax::ext::base::ExtCtxt;
use syntax::parse::token;
use syntax::codemap::DUMMY_SP;
use syntax::parse::token::intern;
use elastic_codegen::api::ast::*;
use elastic_codegen::api::parse;
use elastic_codegen::api::gen::rust::*;
use elastic_codegen::gen::rust::*;
use elastic_codegen::emit::*;
use elastic_codegen::emit::rust::*;
use std::env;

macro_rules! get_ctxt {
	($cx:ident, $ps:ident, $fgc:ident) => {
		
		$cx = ExtCtxt::new(
			&$ps, vec![],
			syntax::ext::expand::ExpansionConfig::default("qquote".to_string()),
			&mut $fgc
		);
		$cx.bt_push(syntax::codemap::ExpnInfo {
			call_site: DUMMY_SP,
			callee: syntax::codemap::NameAndSpan {
				format: syntax::codemap::MacroBang(intern("")),
				allow_internal_unstable: false,
				span: None,
			}
		});
	};
}

fn main() {
    //TODO: Do this properly with getopts
    let mut args = env::args();
    let _ = args.next().unwrap();
    let indir = args.next().unwrap();
    let outdir = args.next().unwrap();
    
    println!("spec: {}", indir);
    println!("output: {}", outdir);
    
    gen_from_source(&indir, &outdir).unwrap();
}

fn gen_from_source(source_dir: &str, dest_dir: &str) -> Result<(), String> {
    //Clear out the contents of the dest_dir
    println!("clearing destination dir...");
    let _ = fs::remove_dir_all(dest_dir).map_err(|e| e.description().to_string());
    let _ = fs::create_dir_all(dest_dir).map_err(|e| e.description().to_string());
    
    //Create an emitter
    let ps = syntax::parse::ParseSess::new();
	let mut fgc = vec![];
	let mut cx;
	get_ctxt!(cx, ps, fgc);
    let emitter = RustEmitter::new(cx);
    
    //Get the spec source
    println!("parsing source spec files...");
    let parsed = try!(parse::from_dir(source_dir).map_err(|e| e.description().to_string()));
    
    for endpoint in parsed {
        //Get the path for this endpoint
        println!("building path for {}...", endpoint.get_name());
        let mut path = try!(endpoint.get_mod_path().map_err(|_| format!("Error parsing path for {}", endpoint.get_name())));    
        let file = match path.len() {
            0 => {
                path.push(endpoint.get_name().to_string());
                "mod".to_string()
            },
            1 => {
                "mod".to_string()
            },
            _ => try!(path.pop().ok_or(format!("Error parsing path filename for {}", endpoint.get_name())))
        };
        
        let dir_path = format!("{}/{}", dest_dir, path.join("/"));
        let file_path = format!("{}/{}.rs", dir_path, file);
        
        //Ensure the path exists
        try!(fs::create_dir_all(&dir_path).map_err(|e| e.description().to_string()));
        
        //Create the file, or open it if it already exists
        let (mut file, is_new) = match OpenOptions::new().write(true).append(true).open(&file_path) {
            Ok(f) => {
                println!("Opened file...");
                (f, false)
            },
            Err(_) => {
                println!("Creating file...");
                (try!(File::create(&file_path).map_err(|e| e.description().to_string())), true)
            }
        };
        
        println!("emitting source for {}...", endpoint.get_name());
        try!(emitter.emit_str(&"//Autogenerated\n", &mut file).map_err(|e| e.description().to_string()));
        try!(file.sync_all().map_err(|e| e.description().to_string()));
        
        //TODO: For files where name is not 'mod', also need to update the 'mod' file in the same dir with a 'use' stmt
    }
    
    Ok(())
}