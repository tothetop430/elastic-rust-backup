//! Elasticsearch Hyper Client Samples
//!
//! This sample executes a simple search request against some indexed data.
//! The data is provided by a struct with mapping generated by `elastic_types`.

#![feature(plugin, custom_derive)]
#![plugin(serde_macros, elastic_types_macros, json_str)]

extern crate serde;
extern crate serde_json;
extern crate elastic_types;
extern crate hyper;
extern crate elastic_hyper as elastic;

use std::net::Ipv4Addr;
use std::{ thread, time };
use elastic_types::mapping::prelude::*;
use elastic_types::response::SearchResponse;
use elastic_types::date::prelude::*;
use hyper::client::Client;

//
#[derive(Clone, Debug, Serialize, Deserialize, ElasticType)]
pub struct MyStruct {
	pub id: i32,
	pub title: String,
	pub timestamp: ElasticDate<DefaultDateFormat>,
	pub geo: GeoLocation
}

#[derive(Clone, Debug, Serialize, Deserialize, ElasticType)]
pub struct GeoLocation {
	pub ip: Ipv4Addr
}

const INDEX: &'static str = "testidx";

fn main() {
	//Create a hyper client
	let (mut client, params) = (Client::new(), elastic::RequestParams::default());

	//Create an index and map our type
	println!("setting up index and mapping...");
	let _ = elastic::indices::create::put_index(&mut client, &params, INDEX, "").unwrap();
	let _ = elastic::indices::put_mapping::put_index_type(
		&mut client, &params,
		INDEX, MyStruct::name(),
		&TypeMapper::to_string(MyStructMapping).unwrap()
	).unwrap();

	//Index some data. For lots of data, prefer the `bulk` mod
	println!("indexing data...");
	for t in get_data() {
		let _ = elastic::index::put_index_type_id(
			&mut client, &params,
			INDEX, MyStruct::name(), &t.id.to_string(),
			&serde_json::to_string(&t).unwrap()
		).unwrap();
	}

	//NOTE: Elasticsearch is _near_ realtime, so results aren't guaranteed to show up right away
	thread::sleep(time::Duration::from_secs(2));

	//Perform a search request and deserialise to `SearchResponse`
	println!("searching...");
	let res: SearchResponse<MyStruct> = serde_json::de::from_reader(
		elastic::search::post_index_type(
			&mut client, &params,
			INDEX, MyStruct::name(),
			json_lit!({
				query: {
					query_string: {
						query: "*"
					}
				}
			})
		).unwrap()
	).unwrap();

	println!("results: {}", res.hits.total);
	for hit in res.hits.hits {
		if let Some(hit) = hit.source {
			println!("hit: {:?}", hit);
		}
	}
}

fn get_data() -> Vec<MyStruct> {
	vec![
		MyStruct {
			id: 1,
			title: String::from("Some Title"),
			timestamp: ElasticDate::now(),
			geo: GeoLocation {
				ip: Ipv4Addr::new(10, 0, 0, 1)
			}
		},
		MyStruct {
			id: 2,
			title: String::from("Some Other Title"),
			timestamp: ElasticDate::now(),
			geo: GeoLocation {
				ip: Ipv4Addr::new(10, 0, 0, 2)
			}
		}
	]
}
