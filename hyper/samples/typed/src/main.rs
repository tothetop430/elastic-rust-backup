//! Elasticsearch Hyper Client Samples
//!
//! This sample assumes you have a node running on `localhost`.
//!
//! This sample executes a simple search request against some indexed data.
//! The data is provided by a struct with mapping generated by `elastic_types`.

#![feature(plugin, custom_derive)]
#![plugin(serde_macros, elastic_types_macros, json_str)]

extern crate serde;
extern crate serde_json;
#[macro_use]
extern crate elastic_types;
extern crate hyper;
extern crate elastic_hyper as elastic;

use std::net::Ipv4Addr;
use std::{ thread, time };
use hyper::Client;
use elastic::RequestParams;
use elastic_types::prelude::*;

mod response;

use response::*;

//The type we want to index in Elasticsearch
#[derive(Clone, Debug, Serialize, Deserialize, ElasticType)]
pub struct MyStruct {
	pub id: i32,
	pub title: String,
	pub timestamp: Date<DefaultDateFormat>,
	pub geo: GeoLocation
}

#[derive(Clone, Debug, Serialize, Deserialize, ElasticType)]
pub struct GeoLocation {
	pub ip: Ipv4Addr,
	pub loc: GeoPoint<DefaultGeoPointFormat>
}

const INDEX: &'static str = "testidx";

fn main() {
	//Create a hyper client
	let (mut client, params) = elastic::default();

	//Create an index and map our type
	create_index(&mut client, &params);

	//Index some objects. For lots of data, prefer the `bulk` mod
	for t in get_data() {
		index_datum(&mut client, &params, &t);
	}

	//NOTE: Elasticsearch is _near_ realtime, so results aren't guaranteed to show up right away
	thread::sleep(time::Duration::from_secs(2));

	//Perform a search request and deserialise to `SearchResponse`
	let res = query(&mut client, &params);

	println!("results: {}", res.hits.total);
	for hit in res.hits.hits {
		if let Some(hit) = hit.source {
			println!("hit: {:?}", hit);
		}
	}
}

fn create_index(client: &mut Client, params: &RequestParams) {
	//Create index
	let _ = elastic::indices::create::put_index(client, &params, INDEX, "").unwrap();

	//Put mapping for MyStruct
	let _ = elastic::indices::put_mapping::put_index_type(client, &params,
		//Index and type
		INDEX, MyStruct::name(),
		//Serialised mapping
		&TypeMapper::to_string(MyStruct::mapping()).unwrap()
	).unwrap();
}

fn get_data() -> Vec<MyStruct> {
	vec![
		MyStruct {
			id: 1,
			title: String::from("Some Title"),
			timestamp: Date::now(),
			geo: GeoLocation {
				ip: Ipv4Addr::new(10, 0, 0, 1),
				loc: GeoPoint::build(-71.34, 41.12)
			}
		},
		MyStruct {
			id: 2,
			title: String::from("Some Other Title"),
			timestamp: Date::now(),
			geo: GeoLocation {
				ip: Ipv4Addr::new(10, 0, 0, 2),
				loc: GeoPoint::build(-71.34, 41.12)
			}
		}
	]
}

fn index_datum(client: &mut Client, params: &RequestParams, datum: &MyStruct) {
	let _ = elastic::index::put_index_type_id(client, &params,
		//Index, type and id
		INDEX, MyStruct::name(), &datum.id.to_string(),
		//Serialised data
		&serde_json::to_string(&datum).unwrap()
	).unwrap();
}

fn query(client: &mut Client, params: &RequestParams) -> SearchResponse<MyStruct> {
	serde_json::de::from_reader(
		elastic::search::post_index_type(client, &params,
			//Index and type
			INDEX, MyStruct::name(),
			//Query
			json_lit!({
				query: {
					query_string: {
						query: "*"
					}
				}
			})
		).unwrap()
	).unwrap()
}
